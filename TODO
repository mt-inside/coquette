front end that uses curses / qt and has 0-60, shift, stats
stats_observer
- move args (period) to ctor
- do proper update notifications
- look at on-line algorithms too
do the TODOs in stream_frame.c etc
reg_infos to gain name, unit name, range
observabled to push their new values (complex type (maybe >1 number like stats) (with units too)) in the update call, as it's silly that you just get a unit type notification then have to ask for the value.
observers should say which registers they want to watch (if there's a choice they should take it in their ctor). Stream_t doesn't need a reg then, it just asks the observers.
observables to report a complex T, not just uint8 (e.g. value + reg_info). IS THIS NECESSARY? WHEN YOU REGISTER FOR UPDATES YOU SHOULD HAVE A REG_INFO TO HAND
when observers notify you of new data they currently just raise an event and you have to ask them for data yourself. This makes it a bit all-or-nothing (though I think observers should stay small and only represent one piece of data)

Make big-endian safe. Extracting LSB by truncation, etc...
how to disconn from ecu to handshake another? Because handshakes start with two command-ends, I wonder if just send a new handshake?

observer callbacks can get their reg from their obs struct. There should be a way to look this up to pretty name and unit enum.
Derive cool stuff - instant and avg MPG, AFR (open and closed loop? ECU is always telling us MAF and fueling, only difference is how it determines fuel). Torque (from fuel and AFR?). Power (from torque and revs).
some kind of framework for unit conversion (engine speed in Hz, road spd in m/s, acceleration in G).
commands to other cpus (each cmd take an ecu and remember / switch if different? OR unified address space for registers (pair cpu & reg) - layer underneath to watch current ecu and switch if necc (sort first to reduce switching))
Mac Serial comms - ioreg -c IOSerialBSDClient

make look like R34 / 35 GT-R, Defi ADVANCE ZD
gauge observer - current value and 10 sec peak - stats observer does this (may need to be able to set window size - in seconds)
log observer...
